using SharpCraft.Core.Blocks;
using SharpCraft.Core.Numerics;
using SharpCraft.Core.WorldGeneration;
using AwesomeAssertions;
using Bogus;

namespace SharpCraft.Core.Tests.WorldGeneration;

public class ChunkTests
{
    private readonly Faker _faker = new();

    [Fact]
    public void SetBlock_ShouldStoreBlockType()
    {
        var chunk = new Chunk(new Vector2<int>(0, 0));
        var x = _faker.Random.Int(0, Chunk.Size - 1);
        var y = _faker.Random.Int(0, Chunk.Height - 1);
        var z = _faker.Random.Int(0, Chunk.Size - 1);
        var type = _faker.PickRandom<BlockType>();
        if (type == BlockType.Air) type = BlockType.Stone; // Ensure we set something non-air for clarity

        chunk.SetBlock(x, y, z, type);
        var block = chunk.GetBlock(x, y, z);

        block.Type.Should().Be(type);
    }

    [Fact]
    public void SetBlock_ShouldSetIsDirtyToTrue()
    {
        var chunk = new Chunk(new Vector2<int>(0, 0));
        // IsDirty is true by default, so we might need to "clean" it if we want to test setting it again.
        // But since we can't easily clean it without GenerateMesh (which requires a World), 
        // we'll just check it starts true.
        
        chunk.IsDirty.Should().BeTrue();
    }

    [Fact]
    public void GetBlock_ShouldReturnAir_WhenOutOfBounds()
    {
        var chunk = new Chunk(new Vector2<int>(0, 0));

        var block = chunk.GetBlock(-1, 0, 0);

        block.Type.Should().Be(BlockType.Air);
    }

    [Fact]
    public void GetBlock_ShouldReturnAir_WhenYIsTooHigh()
    {
        var chunk = new Chunk(new Vector2<int>(0, 0));

        var block = chunk.GetBlock(0, Chunk.Height, 0);

        block.Type.Should().Be(BlockType.Air);
    }

    [Fact]
    public void GenerateMesh_ShouldCreateVerticesAndIndices()
    {
        var world = new World();
        var chunk = new Chunk(new Vector2<int>(0, 0));
        chunk.SetBlock(0, 0, 0, BlockType.Stone);

        chunk.GenerateMesh(world);

        // A single block with no neighbors should have 6 faces.
        // Each face has 4 vertices and 6 indices (2 triangles).
        // Vertices total: 6 * 4 = 24. 
        // Floats in vertices: 24 * 8 (x,y,z,u,v,nx,ny,nz) = 192.
        // Indices total: 6 * 6 = 36.
        chunk.OpaqueMesh.Vertices.Should().HaveCount(192);
        chunk.OpaqueMesh.Indices.Should().HaveCount(36);
        chunk.IsDirty.Should().BeFalse();
    }

    [Fact]
    public void GenerateMesh_ShouldNotRerender_WhenNotDirty()
    {
        var world = new World();
        var chunk = new Chunk(new Vector2<int>(0, 0));
        chunk.SetBlock(0, 0, 0, BlockType.Stone);
        chunk.GenerateMesh(world);
        var firstVertices = chunk.OpaqueMesh.Vertices;

        chunk.GenerateMesh(world);

        chunk.OpaqueMesh.Vertices.Should().BeSameAs(firstVertices);
    }

    [Fact]
    public void GenerateMesh_ShouldOccludeInternalFaces()
    {
        var world = new World();
        var chunk = new Chunk(new Vector2<int>(0, 0));
        // Two blocks side by side
        chunk.SetBlock(0, 0, 0, BlockType.Stone);
        chunk.SetBlock(1, 0, 0, BlockType.Stone);

        chunk.GenerateMesh(world);

        // Each block has 6 faces.
        // The face between them (East of block 0 and West of block 1) should be occluded.
        // Block 0: North, South, Up, Down, West (5 faces)
        // Block 1: North, South, Up, Down, East (5 faces)
        // Total: 10 faces.
        // 10 * 6 indices = 60.
        chunk.OpaqueMesh.Indices.Should().HaveCount(60);
    }

    [Fact]
    public void GenerateMesh_ShouldOccludeCrossChunkFaces()
    {
        var world = new World();
        var chunk0 = world.GetOrCreateChunk(new Vector2<int>(0, 0));
        var chunk1 = world.GetOrCreateChunk(new Vector2<int>(1, 0));

        // Clear chunks to be sure (they might have been generated by DefaultWorldGenerator in World)
        for(var x=0; x<Chunk.Size; x++)
        {
            for (var y = 0; y < Chunk.Height; y++)
            {
                for (var z = 0; z < Chunk.Size; z++)
                {
                    chunk0.SetBlock(x, y, z, BlockType.Air);
                    chunk1.SetBlock(x, y, z, BlockType.Air);
                }
            }
        }

        // Two blocks on the border
        // Block at (15, 0, 0) in chunk (0, 0)
        chunk0.SetBlock(15, 0, 0, BlockType.Stone);
        // Block at (0, 0, 0) in chunk (1, 0) -> World (16, 0, 0)
        chunk1.SetBlock(0, 0, 0, BlockType.Stone);

        chunk0.GenerateMesh(world);

        // Block at (15,0,0) has neighbor at (16,0,0) which is Stone in chunk1.
        // So East face of (15,0,0) should be occluded.
        // Should have 5 faces.
        chunk0.OpaqueMesh.Indices.Should().HaveCount(30);
    }

    [Fact]
    public void GenerateMesh_ShouldSeparateTransparentBlocks()
    {
        var world = new World();
        var chunk = new Chunk(new Vector2<int>(0, 0));
        chunk.SetBlock(0, 0, 0, BlockType.Stone);
        chunk.SetBlock(0, 1, 0, BlockType.Water);

        chunk.GenerateMesh(world);

        // Current implementation:
        // Stone against Water: Stone does NOT render face (5 faces).
        // Water against Stone: Water DOES render face (6 faces).
        
        chunk.OpaqueMesh.Indices.Should().HaveCount(30); // 5 faces for Stone
        chunk.TransparentMesh.Indices.Should().HaveCount(36); // 6 faces for Water
    }
}
